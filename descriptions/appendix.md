# 부록 A

## A.1 ARM 아키텍처 기초 지식

여기서는 ARM 아키텍처에 대한 가장 기본적이고 반드시 알아두어야 할 내용을 정리하여 설명한다.

### A.1.1 익셉션 벡터 테이블

전원이 켜지면 ARM은 익셉션 벡터 테이블의 리셋 벡터를 읽는다. 익셉션 벡터 테이블의 위치는 조정될 수 있고, 대부분은 기본 위치인 0x00000000 메모리 위치에 익셉션 벡터 테이블을 배치한다.

익셉션은 총 7개 있고 중간의 0x14 오프셋은 사용하지 않는다.

ARM은 익셉션 벡터 테이블에 정의된 상황이 발생하면 프로그램 카운터(PC)를 익셉션 벡터 테이블에 정의된 오프셋 주소로 강제 변환한다. 그리고 익셉션 벡터 테이블에 있는 명령을 바로 실행한다.

익셉션 벡터 테이블의 익셉션은 각각 4바이트씩 할당되어 있다. 여기에 브랜치 명령어를 써 놔서 익셉션을 처리하는 코드로 점프하게 만든다. 이 익셉션을 처리하는 코드를 **익셉션 핸들러** 라고 부른다.

```
0x00 Reset                  전원이 켜지면 실행됨
0x04 Undefined Instruction  잘못된 명령어를 실행했을 때
0x08 SVC(Supervisor Call)   SVC 명령으로 발생시키는 익셉션
0x0C Prefetch Abort         명령어 메모리에서 명령어를 읽다가 문제가 생김
0x10 Data Abort             데이터 메모리에서 데이터를 읽다가 문제가 생김
0x14 Not used               사용하지 않음
0x18 IRQ interrupt          IRQ 인터럽트가 발생했을 때
0x1C FIQ interrupt          FIQ 인터럽트가 발생했을 때
```

정리하면, 익셉션이 발생하면 ARM 코어는 프로그램 카운터를 익셉션 벡터 테이블의 익셉션 벡터 오프셋으로 변경한다. 거기에 브랜치 명령을 쓰고 브랜치 명령에 따라 다시 점프하면 익셉션 핸들러로 진입하고, 이 익셉션 핸들러에서 익셉션을 처리한다.

### A.1.2 익셉션의 종류

익셉션이란 주변장치 등에서 발생한 신호를 처리하기 위해 순차적으로 진행하던 프로그램의 수행을 끊는 것을 말한다.

익셉션이 발생했을 때 익셉션 핸들러를 처리하고 나도 프로그램이 망가지지 않고 제대로 동작하도록 작업을 해주어야 한다.

익셉션이 발생하면 프로그램 흐름이 다시 원래 위치로 복귀할 수 있도록 ARM은 하드웨어 수준에서 최소한의 작업을 한다.

그 작업이란 R14(LR)에 복귀할 주소를 자동으로 저장하는 것이다.

개발자는 익셉션 핸들러의 마지막에서 R14_[mode] 에 저장된 값을 이용하여 원래 흐름으로 복귀할 수 있다. 다만 ARM의 파이프라인 때문에 각 익셉션별로 정상 복귀를 하기 위해서는 R14값에 각기 다른 연산을 해 줘야 한다.

### A.1.3 인터럽트

인터럽트는 프로그램의 흐름을 누군가 가로채는 것을 말한다. ARM에서는 인터럽트와 익셉션이 차이 없이 동작한다. 즉 ARM에서는 인터럽트 핸들러와 익셉션 핸들러를 같은 개념으로 생각해도 된다.

인터럽트와 익셉션을 의미적으로 구분하면 인터럽트는 외부 요인에 의해서 발생하는 것이다. 예를 들어 버튼이 눌렸다거나 스마트폰의 액정 화면을 터치했다든가 하는 행동들이 인터럽트를 발생시킨다. 사용자의 행동뿐만 아니라 시간의 흐름에 의해서도 인터럽트는 발생한다. 그 뿐만 아니라 SSD에 데이터를 저장하려고 저장 버튼을 누르는 순간 운영체제는 SSD로 데이터를 보내는데, SSD의 펌웨어 입장에서는 호스트에서 데이터 전송에 해당하는 인터럽트를 전달받게 된다.

ARM은 두 종류의 인터럽트를 제공한다. 하나는 IRQ이고 하나는 FIQ이다. FIQ는 IRQ보다 더 빠른 처리를 목적으로 설계되었다. FIQ가 IRQ보다 빠른 이유는 FIQ 익셉션 동작 모드는 별도로 R8에서 R12까지의 레지스터를 가지고 있기 때문이다. 펌웨어에서 인터럽트 처리를 할 때 R8에서 R12까지만 사용하도록 코드를 작성하면 레지스터를 백업하고 복구하는 시간을 사용하지 않아도 된다.

ARM에는 인터럽트를 감지하는 핀이 IRQ와 FIQ 딱 두개이다. 따라서 인터럽트가 발생했다는 것만 알 수 있지 어떤 인터럽트가 어떤 하드웨어에서 발생했는지를 알 수 없다. 그것을 알려면 인터럽트 컨트롤러에 물어봐야 한다. 인터럽트 컨트롤러는 다음과 같은 기능을 한다.

- 인터럽트가 발생했을 때 해당 인터럽트의 종류를 레지스터에 기록한다.
- 인터럽트가 발생했을 때 ARM의 IRQ 혹은 FIQ에 맞춰서 인터럽트 신호를 준다.
- 특정 인터럽트를 골라서 마스킹(비활성화)할 수 있다.
- 여러 인터럽트 간에 우선순위를 설정할 수 있다.

인터럽트가 발생하면 펌웨어는 다음 세 단계를 수행한다.

1. 인터럽트 컨트롤러에서 인터럽트 소스가 어떤 것인지를 판별한다.
2. 인터럽트 소스에 따라 실행해야 할 인터럽트 서비스 루틴을 선택한다.
3. 해당 인터럽트 소스를 비활성화하고 인터럽트 서비스 루틴으로 진입한다.

### A.1.5 동작 모드와 뱅크드 레지스터

ARM에는 익셉션과 관련하여 동작 모드 라는 개념이 있다. 특정 익셉션이 특정 동작 모드에 연결되어 있기도 하고 익셉션과 상관없이 존재하는 동작 모드도 있다. 동작 모드는 다음과 같이 모두 7개 이다.

- User 모드(USR): 일반적으로 사용하는 모드로 ARM 상태와 Thumb 상태로 동작한다. 만약 운영체제를 사용한다면 사용자 프로그램은 일반적으로 USR 모드에서 동작한다.

- Fast Interrupt 모드(FIQ): FIQ 익셉션이 발생하면 FIQ 모드로 전환된다. 빠른 처리를 위해서 별도로 레지스터를 몇 개 더 가지고 있다. 이러한 별도의 레지스터를 **뱅크드 레지스터**라고 한다.

- Interrupt 모드(IRQ): IRQ 익셉션이 발생하면 IRQ 모드로 전환된다.

- Supervisor 모드(SVC): 운영체제 등에서 시스템 코드를 수행하기 위한 보호 모드이다. 보통 운영체제에서 시스템 콜을 호출하면 SVC 익셉션을 발생시켜 SVC 모드로 전환한 후에 커널 동작을 수행한다. SVC 익셉션은 메모리나 하드웨어에 상관없이 순수하게 소프트웨어에 의해서 발생하는 익셉션이다.

- Abort 모드(ABT): Data abort나 Prefetch abort가 발생했을 때 전환되는 동작 모드이다.

- System 모드(SYS): 운영체제 등에서 사용자 프로세스가 임시로 커널 모드를 획득해야 하는 경우가 있는데, 이때 SYS 모드를 사용한다. SYS 모드는 익셉션과 연관되어 있지 않고 소프트웨어로 모드 전환을 하여 진입할 수 있다.

- Undefined 모드(UND): Undefined instruction이 발생했을 때 진입하는 동작모드이다.

각 동작 모드에 따라 ARM은 각기 다른 레지스터를 가지고 있기도 하고 동작 모드들이 같은 레지스터를 공유하기도 한다. ARM은 작업 레지스터를 모두 37개 가지고 있다. 32비트 범용 레지스터 31개와 상태 레지스터 6개이다. 항상 동시에 37개를 사용하는 것은 아니고, 동작 모드에 따라 사용할 수 있는 레지스터가 다르다.

동작 모드별로 사용할 수 있는 레지스터의 최대 개수는 범용 레지스터 16개와 상태 레지스터 2개이다.

각 동작 모드별로 직접 접근 가능한 레지스터로 R0 ~ R15와 CPSR이 있다.

R0~R12는 범용 레지스터라고 부른다. 펌웨어가 데이터를 일반적으로 처리할 때 사용하는 레지스터이다.

R13은 스택 포인터(SP) 레지스터라고 한다. 대부분의 소프트웨어는 스택을 기반으로 동작하기 때문에 소프트웨어는 스택의 위치를 알아야 하는데, 이 스택의 위치를 추적하는 레지스터가 SP이다.

R14는 링크 레지스터(LR) 이다. 대부분의 소프트웨어는 서브 루틴 호출 혹은 함수 호출로 구성되어 있다. 예를 들어 funcA() 에서 함수 funcB()를 호출한다면, funcB()가 수행을 마치고 리턴했을 때, funcA()으 호출 지점으로 무사히 되돌아 가야 한다. 그 지점을 **리턴 어드레스**라고 부르고, 이 리턴 어드레스를 저장하는 레지스터가 LR이다.

ARM은 여러 종류의 분기 명령어를 가지고 있다. BL, BLX 같은 분기 명령어를 통해 서브 루틴으로 점프하는데, 점프할 때 ARM은 하드웨어가 자동으로 LR에 리턴 어드레스를 넣어준다.

R15는 프로그램 카운터(PC) 이다. 현재 명령어를 실행하고 그다음 명령어를 읽으려면 그다음 명령어가 있는 메모리 주소를 저장하고 있어야 한다. 분기 명령어가 처리되면 PC는 분기로 점프하여 시작되는 서브 루틴의 시작 주소로 변경되고 변경되기 직전의 주소는 LR에 저장된다.

개별 동작 모드는 모두 SP와 LR을 뱅크드 레지스터로 가지고 있다. 그래야만 각 동작 모드가 독립된 스택 영역을 유지할 수 있고 각 동작 모드가 다른 동작 모드의 영향을 받지 않으면서 다른 동작 모드로 원활하게 복귀할 수 있기 때문이다.

이렇게 각 동작 모드에서 공유하지 않고 전용으로 사용하는 레지스터는 같은 이름을 가지고 있지만, 실제로 독립된 공간에 데이터를 저장한다. 이런 레지스터를 ARM에서는 **뱅크드 레지스터** 라고 부른다.

각 동작 모드별로 SP와 LR 그리고 SPSR이 뱅크드 레지스터이다.

### A.1.7 프로그램 상태 레지스터

프로그램이 동작하면서 생기는 많은 상태가 있다. 예를 들면 계산 결과가 음수이거나 0일 때 이것을 상태로 가지고 있어야 수행할 수 있는 동작들이 있다. 이런 상태들을 관리하는 레지스터를 **프로그램 상태 레지스터(PSR)** 이라고 한다.

현재 상태를 저장하는 레지스터는 CPSR 이라고 하고, CPSR을 백업하는 레지스터를 SPSR이라고 한다.

CPSR의 [4:0]은 모드 비트이다. 각 동작 모드별로 비트 설정 값은 다음과 같다.

- 10000: USR
- 10001: FIQ
- 10010: IRQ
- 10011: SVC
- 10111: ABT
- 11011: UND
- 11111: SYS

CPSR[4:0]의 값을 변경하면 동작 모드가 변경된다. 익셉션이 발생했을 때는 하드웨어가 알아서 값을 변경한다.

### A.2 ABI

ABI란 Application Binary Interface의 약자이다. 즉 바이너리 수준에서 애플리케이션이 호환 가능하도록 만든 인터페이스라는 뜻이다. 바이너리 수준이란 쉽게 말해서 컴파일이 완료된 오브젝트 파일을 말한다.

정리하면, 링커가 오브젝트 파일들을 링킹할 수 있도록 함수 호출 방법을 정의한 인터페이스라는 말이다.

- 실행 파일 형식: 컴파일러가 생성하는 바이너리 파일의 구조를 정의.
- 자료형: 프로그래밍 언어가 사용하는 자료형의 실제 크기를 정의.
- 레지스터 사용: 파라미터와 로컬 변수가 레지스터를 몇 개나 사용하는지에 대한 내용을 정의.
- 스택 프레임 조직: 스택을 어떻게 만들지 정의. 예를 들어 스택에 변수가 정의될 때 파라미터가 우선인지 로컬 변수가 우선인지, 선언 순서대로 저장되는지 혹은 선언 순서의 반대로 저장되는지에 대한 내용 정의.
- 호출 규칙: 함수의 인자가 전달되는 방식을 정의. 예를 들어 모든 파라미터가 스택으로 전달되는지 또는 일부는 레지스터를 사용하는지에 대한 정의.

이 책에서 사용하는 GCC의 파일 명은 arm-none-eabi-gcc이다. EABI 는 Embedded ABI로, 임베디드 환경에서 사용하는 ABI를 정해 놓은 것이다.

EABI와 ABI의 가장 큰 차이점은 동적 링크의 지원 유무이다. 윈도우에서 .dll 파일이나 리눅스에서 .so 파일인 동적 라이브러리는 EABI에서 지원되지 않는다. 무조건 정적 링크만 지원된다. 펌웨어는 그 자체로 필요한 모든 가능을 다 포함하고 있는 바이너리여야 한다.

### A.3 실행 파일 형식

GCC 등의 컴파일러로 오브젝트 파일을 만들고 링커로 라이브러리를 링킹하고 나면 최종 결과물로 실행 파일이 나온다. 이 파일들은 대부분 ELF 파일 형식으로 만들어진다. ELF는 Executable and Linkable Format의 약자이다.

ELF 파일 형식은 크게 두 부분으로 구분된다. 첫 번째는 ELF 헤더이고, 두 번째는 섹션이다. 

ELF 헤더는 ELF 포맷이 지정하는 여러 정보를 담고 있는 자료구조이다. 운영체제나 임베디드 시스템의 로더는 이 ELF 헤더를 읽은 후 필요한 데이터를 찾아서 메모리에 복사하고 CPU의 레지스터 값을 조정해서 파일을 실행한다.

ELF 섹션에는 이름이 있다. 각각 .text, .rdata, .bss, .symtab, .rel.text, .rel.data, .debug, .line, .strtab 이다.

섹션의 이름은 점으로 시작하는 단어이다.

- .text: 컴파일러가 만든 기계어가 위치하는 섹션. 

- .rdata: 읽기 전용 데이터를 말한다. C언어를 기준으로 const로 선언된 값이나 코드 안에 직접 숫자로 써 넣은 값이 여기에 위치한다.

- .data: 초기화된 전역 변수가 위치한다.

- .bss: 초기화되지 않은 전역 변수가 위치한다. 이 섹션에 위치한 전역 변수들은 나중에 0으로 초기화된다. 나중에 0으로 초기화될 것이므로 이 섹션에서 변수들은 자신의 크기만큼 자리를 차지하고 있지 않고, 크기 정보만 가지고 있는다.

- .symtab: 심벌 테이블이다. 전역 변수와 함수에 대한 심벌을 저장한다. 링커가 링킹을 할 때 다른 바이너리 파일의 rel.text와 rel.data에 있는 심벌 정보와 이 섹션에 있는 심벌 정보를 연결해서 메모리 오프셋을 지정해 주는 것이다.

- .rel.text, .rel.data: 다른 파일에 선언된 전역 변수나 함수를 호출할 때 컴파일러는 소스 파일 내에서 해당 심벌을 찾을 수 없으므로 일단 비워두고 이 섹션에 정보를 기록한다. 그러면 나중에 링커가 이 섹션의 데이터를 읽어서 다른 파일의 정보와 연결해 준다.

- .debug: 디버거로 디버깅할 때 바이너리 파일을 읽었는데 변수 이름과 함수 이름이 보인다. 해당 정보가 전역 변수나 함수 이름이면 .symtab에서 읽고 로컬 변수일 때는 이 섹션에서 읽어온다. GCC의 컴파일 옵션에서 -g 옵션을 주어야만 이 섹션이 생성된다.

- .line: 디버거로 디버깅할 때 C언어 한 줄이 어셈블리어 여러 줄로 연결되어 보여진다. 이런 정보가 이 섹션에 기록되어 있다. .debug와 마찬가지로 GCC에서 -g 옵션을 주어야만 생성되는 섹션이다.

- .strtab: ELF 파일 전체에 사용되는 문자열 정보가 이 섹션에 기록되어 있다.

링커는 ELF 파일의 헤더와 섹션 정보를 읽어서 오브젝트 파일을 하나로 묶은 다음 실행 가능한 최종 바이너리 파일을 만들어 낸다. 최종 바이너리 파일 자체도 ELF 파일이다.