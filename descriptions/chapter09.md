## 9. 스케줄러

스케줄러란 지금 실행 중인 태스크 다음에 실행할 태스크가 무엇인지 골라주는 것이다.

### 9.1 간단한 스케줄러

가장 간단한 스케줄러는 현재 실행중인 태스크 컨트롤 블록의 바로 다음 태스크 컨트롤 블록을 선택하면 된다. 

다른 추가 계산 없이 그냥 인덱스를 계속 증가시키면서 대상을 선택하는 알고리즘을 **라운드 로빈 알고리즘** 이라고 한다. 인덱스가 정해진 최댓값에 이르면 그 다음 인덱스는 0이 된다.

```c
static uint32_t sCurrent_tcb_index;
static KernelTcb_t* Scheduler_round_robin_algorithm(void) {
  ++sCurrent_tcb_index;
  sCurrent_tcb_index %= sAllocated_tcb_index;

  return &sTask_list[sCurrent_tcb_index];
}
```
sCurrent_tcb_index에 현재 실행 중인 태스크의 태스크 컨텍스트 블록 인덱스를 저장한다. 이렇게 만든 알고리즘 코드를 컨텍스트 스위칭에 적용하면 된다.

### 9.2 우선순위 스케줄러

우선순위 스케줄러란 태스크 우선순위가 있어서 스케줄러가 낮은 우선순위 태스크를 높은 우선순위 태스크가 동작하는 동안 다음에 동작할 태스크로 선택하지 않는 것을 말한다.

태스크 컨트롤 블록에 우선순위 멤버 변수를 추가하여 구현할 수 있다.

### 9.3 요약

스케줄러는 여러 알고리즘으로 구현할 수 있다. 스케줄러로 어떤 알고리즘을 쓰느냐에 따라 태스크 컨트롤 블록의 설계가 달라지기도 한다. 이 책에서는 이해하기 쉬운 코드를 만드는 것을 가장 중요한 목표로 하고 있으므로 가장 기본적인 라운드 로빈 스케줄러를 만들었다.

다음 장에서는 컨텍스트 스위칭을 구현하여 멀티태스킹 커널을 만들어 본다.